name: Create Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type de release'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: 'Version personnalis√©e (optionnel)'
        required: false
        type: string
  workflow_run:
    workflows: ['Branch CI', 'Deploy to DockerHub']
    types: [completed]
    branches: [main]

jobs:
  analyze-commits:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    outputs:
      should_release: ${{ steps.check-commits.outputs.should_release }}
      release_type: ${{ steps.check-commits.outputs.release_type }}
      new_version: ${{ steps.bump-version.outputs.new_version }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Log trigger source
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "üöÄ Release d√©clench√©e manuellement"
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "üöÄ Release d√©clench√©e apr√®s succ√®s de ${{ github.event.workflow_run.name }}"
          else
            echo "üöÄ Release d√©clench√©e par push sur main"
          fi

      - name: Check for conventional commits
        id: check-commits
        run: |
          # Obtenir la derni√®re version tagg√©e ou HEAD^ si pas de tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo HEAD^)

          # R√©cup√©rer tous les commits depuis la derni√®re version
          ALL_COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s")

          # V√©rifier s'il y a des commits conventionnels
          FEATURES=$(echo "$ALL_COMMITS" | grep -E "^feat:" || echo "")
          FIXES=$(echo "$ALL_COMMITS" | grep -E "^fix:" || echo "")
          BREAKING=$(echo "$ALL_COMMITS" | grep -E "BREAKING CHANGE" || echo "")

          # D√©terminer le type de release
          if [ -n "$BREAKING" ]; then
            RELEASE_TYPE="major"
          elif [ -n "$FEATURES" ]; then
            RELEASE_TYPE="minor"
          elif [ -n "$FIXES" ]; then
            RELEASE_TYPE="patch"
          else
            RELEASE_TYPE="none"
          fi

          # D√©terminer si on doit cr√©er une release
          if [ "$RELEASE_TYPE" != "none" ] || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SHOULD_RELEASE="true"
          else
            SHOULD_RELEASE="false"
          fi

          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

          echo "Commits analys√©s depuis $LAST_TAG:"
          echo "Features: $(echo "$FEATURES" | wc -l)"
          echo "Fixes: $(echo "$FIXES" | wc -l)"
          echo "Breaking changes: $(echo "$BREAKING" | wc -l)"
          echo "Release type: $RELEASE_TYPE"
          echo "Should release: $SHOULD_RELEASE"

      - name: Bump version
        id: bump-version
        if: steps.check-commits.outputs.should_release == 'true'
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -n "${{ github.event.inputs.custom_version }}" ]; then
              NEW_VERSION="${{ github.event.inputs.custom_version }}"
            else
              RELEASE_TYPE="${{ github.event.inputs.release_type }}"
              # Logique de bump de version en bash
              IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
              case "$RELEASE_TYPE" in
                "major")
                  NEW_MAJOR=$((MAJOR + 1))
                  NEW_VERSION="$NEW_MAJOR.0.0"
                  ;;
                "minor")
                  NEW_MINOR=$((MINOR + 1))
                  NEW_VERSION="$MAJOR.$NEW_MINOR.0"
                  ;;
                "patch")
                  NEW_PATCH=$((PATCH + 1))
                  NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
                  ;;
              esac
            fi
          else
            RELEASE_TYPE="${{ steps.check-commits.outputs.release_type }}"
            # Logique de bump de version en bash
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            case "$RELEASE_TYPE" in
              "major")
                NEW_MAJOR=$((MAJOR + 1))
                NEW_VERSION="$NEW_MAJOR.0.0"
                ;;
              "minor")
                NEW_MINOR=$((MINOR + 1))
                NEW_VERSION="$MAJOR.$NEW_MINOR.0"
                ;;
              "patch")
                NEW_PATCH=$((PATCH + 1))
                NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
                ;;
            esac
          fi

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Bumping version from $CURRENT_VERSION to $NEW_VERSION"

  create-release:
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Update package.json version
        run: |
          NEW_VERSION="${{ needs.analyze-commits.outputs.new_version }}"
          npm version $NEW_VERSION --no-git-tag-version
          echo "Version updated to $NEW_VERSION"

      - name: Get commit messages by type
        id: get-commits
        run: |
          # Obtenir la derni√®re version tagg√©e ou HEAD^ si pas de tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo HEAD^)

          # R√©cup√©rer tous les commits depuis la derni√®re version
          ALL_COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s")

          # Cat√©goriser les commits par type
          FEATURES=$(echo "$ALL_COMMITS" | grep -E "^feat:" || echo "")
          FIXES=$(echo "$ALL_COMMITS" | grep -E "^fix:" || echo "")
          DOCS=$(echo "$ALL_COMMITS" | grep -E "^docs:" || echo "")
          CHORES=$(echo "$ALL_COMMITS" | grep -E "^chore:" || echo "")
          REFACTORS=$(echo "$ALL_COMMITS" | grep -E "^refactor:" || echo "")
          TESTS=$(echo "$ALL_COMMITS" | grep -E "^test:" || echo "")
          STYLES=$(echo "$ALL_COMMITS" | grep -E "^style:" || echo "")
          PERFS=$(echo "$ALL_COMMITS" | grep -E "^perf:" || echo "")

          # Formater les commits pour le changelog
          format_commits() {
            echo "$1" | while IFS= read -r commit; do
              if [ -n "$commit" ]; then
                # Extraire le message sans le pr√©fixe
                message=$(echo "$commit" | sed 's/^[^:]*: //')
                echo "- $message"
              fi
            done
          }

          # Stocker les commits format√©s
          echo "features<<EOF" >> $GITHUB_OUTPUT
          format_commits "$FEATURES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "fixes<<EOF" >> $GITHUB_OUTPUT
          format_commits "$FIXES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "docs<<EOF" >> $GITHUB_OUTPUT
          format_commits "$DOCS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "chores<<EOF" >> $GITHUB_OUTPUT
          format_commits "$CHORES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "refactors<<EOF" >> $GITHUB_OUTPUT
          format_commits "$REFACTORS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "tests<<EOF" >> $GITHUB_OUTPUT
          format_commits "$TESTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "styles<<EOF" >> $GITHUB_OUTPUT
          format_commits "$STYLES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "perfs<<EOF" >> $GITHUB_OUTPUT
          format_commits "$PERFS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        id: update-changelog
        run: |
          VERSION="${{ needs.analyze-commits.outputs.new_version }}"
          CURRENT_DATE=$(date +%Y-%m-%d)

          # Cr√©er une entr√©e pour la nouvelle version
          cat > temp_changelog.md << EOF
          ## [$VERSION] - $CURRENT_DATE

          EOF

          # Ajouter les fonctionnalit√©s si elles existent
          if [ -n "${{ steps.get-commits.outputs.features }}" ]; then
            cat >> temp_changelog.md << EOF
          ### üöÄ Ajout√©
          ${{ steps.get-commits.outputs.features }}

          EOF
          fi

          # Ajouter les corrections si elles existent
          if [ -n "${{ steps.get-commits.outputs.fixes }}" ]; then
            cat >> temp_changelog.md << EOF
          ### üêõ Corrig√©
          ${{ steps.get-commits.outputs.fixes }}

          EOF
          fi

          # Ajouter la documentation si elle existe
          if [ -n "${{ steps.get-commits.outputs.docs }}" ]; then
            cat >> temp_changelog.md << EOF
          ### üìö Documentation
          ${{ steps.get-commits.outputs.docs }}

          EOF
          fi

          # Ajouter les refactorisations si elles existent
          if [ -n "${{ steps.get-commits.outputs.refactors }}" ]; then
            cat >> temp_changelog.md << EOF
          ### ‚ôªÔ∏è Refactorisation
          ${{ steps.get-commits.outputs.refactors }}

          EOF
          fi

          # Ajouter les tests si ils existent
          if [ -n "${{ steps.get-commits.outputs.tests }}" ]; then
            cat >> temp_changelog.md << EOF
          ### üß™ Tests
          ${{ steps.get-commits.outputs.tests }}

          EOF
          fi

          # Ajouter les styles si ils existent
          if [ -n "${{ steps.get-commits.outputs.styles }}" ]; then
            cat >> temp_changelog.md << EOF
          ### üíÑ Style
          ${{ steps.get-commits.outputs.styles }}

          EOF
          fi

          # Ajouter les performances si elles existent
          if [ -n "${{ steps.get-commits.outputs.perfs }}" ]; then
            cat >> temp_changelog.md << EOF
          ### ‚ö° Performance
          ${{ steps.get-commits.outputs.perfs }}

          EOF
          fi

          # Ajouter les t√¢ches de maintenance si elles existent
          if [ -n "${{ steps.get-commits.outputs.chores }}" ]; then
            cat >> temp_changelog.md << EOF
          ### üîß Maintenance
          ${{ steps.get-commits.outputs.chores }}

          EOF
          fi

          # Ajouter la ligne de s√©paration
          cat >> temp_changelog.md << EOF
          ---

          EOF

          # Ajouter au d√©but du CHANGELOG.md (apr√®s la section Unreleased)
          if grep -q "## \[Unreleased\]" CHANGELOG.md; then
            # Ins√©rer apr√®s la ligne Unreleased
            sed -i "/^## \[Unreleased\]/r temp_changelog.md" CHANGELOG.md
          else
            # Si pas de section Unreleased, ajouter au d√©but
            cat temp_changelog.md CHANGELOG.md > temp_combined.md
            mv temp_combined.md CHANGELOG.md
          fi
          rm temp_changelog.md

          echo "CHANGELOG mis √† jour pour la version $VERSION avec cat√©gorisation des commits"

      - name: Commit and push changes
        run: |
          git add package.json CHANGELOG.md
          git commit -m "chore: bump version to ${{ needs.analyze-commits.outputs.new_version }} and update CHANGELOG"
          git push origin main

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.analyze-commits.outputs.new_version }}
          name: Release v${{ needs.analyze-commits.outputs.new_version }}
          body: |
            ## What's Changed

            ${{ steps.get-commits.outputs.features != '' && '### üöÄ Nouvelles Fonctionnalit√©s' || '' }}
            ${{ steps.get-commits.outputs.features }}

            ${{ steps.get-commits.outputs.fixes != '' && '### üêõ Corrections' || '' }}
            ${{ steps.get-commits.outputs.fixes }}

            ${{ steps.get-commits.outputs.docs != '' && '### üìö Documentation' || '' }}
            ${{ steps.get-commits.outputs.docs }}

            ${{ steps.get-commits.outputs.refactors != '' && '### ‚ôªÔ∏è Refactorisations' || '' }}
            ${{ steps.get-commits.outputs.refactors }}

            ${{ steps.get-commits.outputs.tests != '' && '### üß™ Tests' || '' }}
            ${{ steps.get-commits.outputs.tests }}

            ${{ steps.get-commits.outputs.perfs != '' && '### ‚ö° Performances' || '' }}
            ${{ steps.get-commits.outputs.perfs }}

            ${{ steps.get-commits.outputs.chores != '' && '### üîß Maintenance' || '' }}
            ${{ steps.get-commits.outputs.chores }}

            ## Docker Images
            - Latest: `${{ secrets.DOCKERHUB_USERNAME }}/benevoclic-web:latest`
            - Version: `${{ secrets.DOCKERHUB_USERNAME }}/benevoclic-web:${{ needs.analyze-commits.outputs.new_version }}`
            - Commit: `${{ secrets.DOCKERHUB_USERNAME }}/benevoclic-web:${{ github.sha }}`

            ## üìã CHANGELOG

            Consultez le [CHANGELOG.md](CHANGELOG.md) pour plus de d√©tails.

            ## üöÄ D√©clenchement

            ${{ github.event_name == 'workflow_dispatch' && 'Release d√©clench√©e manuellement' || 'Release d√©clench√©e automatiquement bas√©e sur les commits conventionnels' }}
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

  # Pas de d√©ploiement dans le workflow release pour le web; utilisez le workflow de d√©ploiement manuel
